#summary description of the JsonML AST format used by the es5 parser
#labels Phase-Design,Parser

== Table of Contents ==

<wiki:toc />

=== Parser Playground ===

[http://es-lab.googlecode.com/svn/trunk/site/esparser/index.html ES5 Parser Playground]

=== AST Format ===

Abstract syntax trees (ASTs) are generated in [http://jsonml.org JsonML] format and are of the form:

{{{
 [ "Type",
   { key : value properties },
   childNode1,
   childNode2,
   ... ]
}}} 

For an overview of all the different kinds of AST nodes, see the [http://code.google.com/p/es-lab/source/browse/trunk/tests/parser/parsertests.js test-suite] for the parser or the [#Visitor_Protocol_Summary summary] below.

=== Types ===

By convention, the last 4 letters of "Type" represent a subtype:
|| Expressions || `*Expr` ||
|| Statements || `*Stmt` ||
|| Declarations || `*Decl` ||
|| Property definitions || `*Prop` ||
|| Patterns || `*Patt` ||
|| Case | !DefaultCase || `*Case` (only within a `SwitchStmt`) ||
|| Empty marker || `Empty` (for elisions in Array-literals, omitted parts of a For-statement and names of anonymous function expressions) ||

All use-occurrences of variables appear as `IdExpr` nodes. All defining occurrences of variables appear as `IdPatt` nodes.

=== Mandatory Attributes ===

The `key:value` attributes of the AST format are used by some nodes:
 
|| `type: string` || in `LiteralExpr` to denote type of literal ||
|| `value: object`|| in `LiteralExpr` to denote value of parsed literal ||
|| `name: string` || in `IdPatt`, `IdExpr`, and `*Prop` to denote the name of a variable or property||
|| `label: string` || in `ContinueStmt`, `BreakStmt` and `LabelledStmt` to denote label name ||
|| `op: string` || in `UnaryExpr`, `BinaryExpr`, `CountExpr` and `AssignExpr` to denote operator punctuator ||
|| `isPrefix: boolean` || in `CountExpr` to denote pre- or postfix operator ||
|| `body: string` || in `RegExpExpr` to denote body of a regexp ||
|| `flags: string` || in `RegExpExpr` to denote flags of a regexp ||
|| `directive: string` || in `PrologueDecl` to denote the source contents of a directive prologue (not yet implemented -- see issue 5) ||

=== Optional Attributes ===

Language processors are allowed to add additional, optional, attributes. Some useful attributes that could be supported for most AST nodes:

==== Verification and scoping Attributes ====

Added during verification and scope analysis: 

|| `strict: boolean` || whether this AST occurs in strict code ||
|| `preOrder: number` || uniquely identify this node within its overall AST ||
|| `definition: number` || On an `IdExpr`, records the `preOrder:` number of the `IdPatt`, if any, of the corresponding definition. ||
|| `scope: number` || On an `IdPatt`, records the `preOrder:` of the containing node in which this definition is in scope. ||

Because of the limits of JsonML, some of the results of scope analysis cannot conveniently be represented within the AST itself, such as a list of free variable references. Rather, the preOrder numbers assigned here can be used as an index into a side table containing the results of scope analysis.

The `definition:` attribute of an `IdExpr` is `-1` if this `IdExpr` is a free occurrence, or `NaN` if static scoping is ambiguous. A static scoping ambiguity cannot appear in a strict `Program`, but it can appear in a strict function within a non-strict `Program`.

==== Debugging Attributes ====

To be captured during parsing, for supporting both live and post-mortem source level debugging: 

|| `source: string` || identifies the source from which the AST was parsed ||
|| `startLine: number` || line number indicating start of span ||
|| `startColumn: number` || column number indicating start of span ||
|| `endLine: number` || line number indicating end of span ||
|| `endColumn: number` || column number indicating end of span ||

The `source:` string should serve much the same purpose as does Java's fully qualified path name. It identifies where the source is to be found relative to some root, so that debugging log records together with a source tree are relocatable. We postpone specifying the form of this string awaiting accepted module and package proposals.

Line counts start at 1. Column counts start at 0. If `startLine:` is included but `endLine:` is omitted, then `endLine:` defaults to `startLine:`. If `startColumn:` is omitted, then `startColumn:` defaults to 0. If `endColumn:` is omitted, `endColumn:` defaults to the last column of `endLine:`.

==== Additional Optional Parsing Attributes ====

|| `comment: string` || last comment appearing before this AST node ||

Some tools process directives buried in comments. Most often, such directives are in the last comment prior to the AST node they apply to. For more general capture of all comments, it is not clear how to represent that adequately in an abstract syntax tree structure, as opposed to a concrete parse tree structure, since some structural information is lost. Perhaps also in a side table indexed by `preOrder:`

=== Issues ===

Not entirely sure whether the literal node for `null` is valid JsonML:
{{{
[ "LiteralExpr", {type: "null", value: null} ]
}}}

The `value:` attribute contains the value `null` which is valid JSON, but may not be valid JsonML? If `null` is not valid JsonML, we should consider dropping the `value:` attribute for this node (at the expense of breaking uniformity with the other `LiteralExpr` nodes)

=== Visitor Protocol Summary ===

|| `visitThisExpr({})` || `this` ||
|| `visitIdExpr({name})` || `name` ||
|| `visitRegExpExpr({body, flags})` || `/body/flags` ||
|| `visitLiteralExpr({type, value})` || `'value'` ||
|| `visitArrayExpr({}, ...optElementExprs)` || `[..]` ||
|| --> ` visitEmpty({})` || `,,` ||
|| `visitObjectExpr({}, ...props)` || `({..})` ||
|| --> ` visitDataProp({name}, valueExpr)` || `name: value` ||
|| --> ` visitGetterProp({name}, funcExpr)` || `get name(){..}` ||
|| --> ` visitSetterProp({name}, funcExpr)`     || `set name(v){..}` ||
|| `visitMemberExpr({}, baseExpr, propExpr)` || `base[prop]` ||
|| `visitInvokeExpr({}, baseExpr, propExpr, ...argExprs)` || `base[prop](...args)` ||
|| `visitCallExpr({}, baseExpr, ...argExprs)` || `base(...args)` ||
|| `visitNewExpr({}, baseExpr, ...argExprs)` || `new base(...args)` ||
|| `visitTypeofExpr({}, xExpr)` || `typeof x` ||
|| `visitUnaryExpr({op}, xExpr)` || `op x` ||
|| `visitBinaryExpr({op}, xExpr, yExpr)` || `x op y` ||
|| `visitLogicalAndExpr({}, xExpr, yExpr)` || `x && y` ||
|| `visitLogicalOrExpr({}, xExpr, yExpr)` || `x |` `| y`||
|| `visitConditionalExpr({}, xExpr, yExpr, zExpr)` || `x ? y : z` ||
|| `visitAssignExpr({op}, lValue, rValue)` || `lValue op rValue` ||
|| `visitCountExpr({op, isPrefix}, lValue)` || `((++|--)lValue | lValue(++|--))` ||
|| `visitDeleteExpr({}, lValue)` || `delete lValue` ||

|| `visitEvalExpr({}, xExpr)` || `eval(x)` ||
|| `visitFunctionExpr({}, optIdPatt, paramDecl, ...parts)` || `(function optId(...params) {..prologue; ..stmts})` ||
|| `visitFunctionDecl({}, idPatt, paramDecl, ...parts)` || `function id(...params) {..prologue; ..stmts}` ||
|| --> ` visitPrologueDecl({directive})` || `'directive';` ||
|| `visitVarDecl({}, ...varPatts)` || `var ..` ||
|| --> ` visitInitPatt({}, idPatt, initExpr)` || `id = init` ||
|| --> ` visitIdPatt({name})` || `name` ||
|| `visitBlockStmt({}, ...stmts)` || `{..}` ||
|| `visitEmptyStmt({})` || `;` ||
|| `visitIfStmt({}, condExpr, thenStmt, elseStmt)` || `if (cond) {t} else {e}` ||
|| `visitDoWhileStmt({}, bodyStmt, condExpr)` || `do body while (cond)` ||
|| `visitWhileStmt({}, condExpr, bodyStmt)` || `while (cond) body` ||
|| `visitForStmt({}, initPart, condExpr, incrExpr, bodyStmt)` || `for (init; cond; incr) body` ||
|| `visitForInStmt({}, lValue, collExpr, bodyStmt)` || `for (lValue in coll) body` ||
|| `visitContinueStmt({label?})` || `continue optLabel` ||
|| `visitBreakStmt({label?})` || `break optLabel` ||
|| `visitReturnStmt({}, optExpr)` || `return optExpr` ||
|| `visitWithStmt({}, headExpr, bodyStmt)` || `with (head) {body}` ||
|| `visitSwitchStmt({}, headExpr, ...cases)` || `switch (head) {..}` ||
|| --> ` visitCase({}, headExpr, ...stmts)` || `case head: ..stmts` ||
|| --> ` visitDefaultCase({}, ...stmts)` || `default: ..stmts` ||
|| `visitLabelledStatement({label}, bodyStmt)` || `label: body` ||
|| `visitThrowStmt({}, errExpr)` || `throw err` ||
|| `visitTryCatchStmt({}, tStmt, errPatt, cStmt)` || `try {t} catch (err) {c}` ||
|| `visitTryFinallyStmt({}, tStmt, fStmt)` || `try {t} finally {f}` ||
|| `visitTryCatchFinallyStmt({}, tStmt, errPatt, cStmt, fStmt)` || `try {t} catch (err) {c} finally {f}` ||
|| `visitDebuggerStmt({})` || `debugger` ||