#summary A traits library for ES5

= Introduction =

The file [http://code.google.com/p/es-lab/source/browse/trunk/src/traits/traits.js traits.js] provides an [http://www.ecma-international.org/publications/standards/Ecma-262.htm ES5] implementation of Traits as defined in [[#References 1]] but closer to the object-based, lexically nestable traits defined in: [[#References 2]]. The library has been successfully tested on Rhino (v1.7 release 3).

= Background: Traits =

Traits were originally defines as 'composable units of behavior' [[#References 1]]: reusable groups of methods that could be composed together to form a class. Traits may _provide_ and _require_ a number of methods. Required methods are like abstract methods in OO class hierarchies: their implementation should be provided by another trait or class.

The big difference between traits and alternative composition techniques such as multiple inheritance and mixins is that upon trait composition, name conflicts (a.k.a. name clashes) should be explicitly resolved by the composer. This is in contrast to mixins and multiple inheritance, which define a certain linearization order that defines an implicit precedence between the composed entities, with one entity shadowing the methods of another entity. While such systems often work for well in small reuse scenario's, they are not robust: small changes in the way mixins/classes are ordered somewhere far away may impact the way name clashes are resolve further down the inheritance/mixin chain. In addition, the linearization enforced by mixins/multiple inheritance implies that it's not possible for a composer to favor a method m1 from one mixin/class A and a method m2 from another mixin/class B: either all of A's methods take precedence, or all of B's methods take precedence.

= Traits for Javascript =

A trait can be any object. It can depend on mutable state, but it is advised to always expose such stateful traits via 'maker' functions, to prevent a stateful trait from being composed multiple times with different objects (this is possible, but state is then shared between the two composers, which may result in very bad interactions).

In the general case, traits _provide_ a set of properties and may _require_ a set of properties, to be provided by other objects.

Traits can be composed into 'composite' traits. The composite consists of all of the own properties of the composed traits. The lexical scope of composed methods remains unmodified. However, the binding of `this` within a trait's method does not necessarily refer to the object literal in which it was defined. When trait methods are composed into a composite, `this` will refer to the composite. Hence, if a trait `T` defines a method `m` that requires (depends on) the method `r`, `m` should call this method using `this.r(...)`.

When two or more traits that define a property with the same name are composed, the composite property will be marked as a "conflict". Accessing a "conflict" property will raise an exception at runtime. 

At composition time, the composer can avoid name clashes by means of two operations:
  * either by *aliasing*, i.e. by renaming one of the conflicting properties in the composite
  * or by *exclusion*, i.e. by excluding one the conflicting properties from the composite

Traits form a composition mechanism that is entirely orthogonal to prototype-delegation (i.e. inheritance between objects). The 'parent' object of a trait is of no consequence: it is ignored during composition (composition of traits looks only at 'own' properties). Traits are assumed to be composed only via trait composition, not by means of delegation.

However, once all traits are composed into a composite that should be used as a 'finalized' or 'completed' object, that 'completed' object can itself take part in prototype-delegation like any other regular object. It may delegate to a parent object, and it may itself be delegated to by other objects.

TODO:
  * traits: summary, background, references
  * explain library API, four composition operators
  * explain `required` convention
  * diamond inheritance of methods
  * branding / testing 'type' of composed objects
  * performance and partial evaluation
  * show an example
  * compare with original traits (cf. Grafts proposal, compile-time vs run-time entities, state, computed exclude vs class precedence over traits)

== References ==

  * [1] "Traits: Composable units of Behavior" (Scharli et. al, ECOOP 2003) ([http://scg.unibe.ch/archive/papers/Scha03aTraits.pdf paper])
  * [2] "Adding State and Visibility Control to Traits using Lexical Nesting" (Van Cutsem et. al, ECOOP 2009) ([http://prog.vub.ac.be/Publications/2009/vub-prog-tr-09-04.pdf paper])
  * [3] [http://www.stefan-marr.de/pages/request-for-comments-horizontal-reuse-for-php Horizontal Reuse for PHP]: 'traits' vs 'grafts'