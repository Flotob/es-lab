#summary A traits library for ES5

= Introduction =

The file [http://code.google.com/p/es-lab/source/browse/trunk/src/traits/traits.js traits.js] provides an [http://www.ecma-international.org/publications/standards/Ecma-262.htm ES5] implementation of Traits as defined in [[#References 1]] but closer to the object-based, lexically nestable traits defined in: [[#References 2]]. The library has been successfully tested on Rhino (v1.7 release 3).

= Background: Traits =

Traits were originally defines as 'composable units of behavior' [[#References 1]]: reusable groups of methods that could be composed together to form a class. Their purpose is to encourage _reuse_ of methods across class hierarchies. Single-inheritance languages often suffer from methods being duplicated across hierarchies because single inheritance can only describe reuse trees, not graphs, often forcing programmers to violate the DRY principle.

Traits may _provide_ and _require_ a number of methods. Required methods are like abstract methods in OO class hierarchies: their implementation should be provided by another trait or class. For example, "enumerability" of a collection object can be encoded as a trait providing all kinds of higher-order methods on collections based on a single method `each` that returns successive elements of the collection (cf. Ruby's [http://ruby-doc.org/core/classes/Enumerable.html Enumerable module]) (I used pseudo-code for clarity):

{{{
trait Enumerable {
  provide {
    map: function(fun) { var r = []; this.each(function (e) { r.push(fun(e)); }); return r; },
    inject: function(init, accum) { var r = init; this.each(function (e) { r = accum(r,e); }); return r; },
  }
  require {
    each: function(fun);
  }
}

class Range(from, to) uses Enumerable {
  function each(fun) { for (var i = from; i < to; i++) { return fun(i) } }
}

var r = new Range(0,5);
r.inject(0,function(a,b){return a+b;}); // 10
}}}

Traits are not meant to be instantiated or used directly. They are only used for reuse and composition.
Traits can be recursively composed into larger, but possibly still incomplete, composite traits. Classes can be composed with traits, and when they do, they should ensure that the requirements and 

The big difference between traits and alternative composition techniques such as multiple inheritance and mixins is that upon trait composition, name conflicts (a.k.a. name clashes) should be explicitly resolved by the composer. This is in contrast to mixins and multiple inheritance, which define a certain linearization order that defines an implicit precedence between the composed entities, with one entity shadowing the methods of another entity. While such systems often work for well in small reuse scenario's, they are not robust: small changes in the way mixins/classes are ordered somewhere far away may impact the way name clashes are resolve further down the inheritance/mixin chain. In addition, the linearization enforced by mixins/multiple inheritance implies that it's not possible for a composer to favor a method m1 from one mixin/class A and a method m2 from another mixin/class B: either all of A's methods take precedence, or all of B's methods take precedence.

Traits allow composers to resolve name clashes by means of 2 fundamental "composition operators":
  * *aliasing*: the composer may choose to import a method under a different (non-conflicting) name
  * *exclusion*: the composer may choose to explicitly exclude a name from the composition

Trait composition is declarative in the sense that the ordering of the composed traits does not matter. In other words, unlike mixins/multiple inheritance, trait composition is commutative and associative. This tremendously reduces the burden of reasoning about deeply nested levels of trait composition.

= Traits for Javascript =

The above `Enumerable` example can be encoded using `traits.js` as follows:

{{{
var EnumerableTrait = {
  each: required, // should be provided by the composite
  map: function(fun) { var r = []; this.each(function (e) { r.push(fun(e)); }); return r; },
  inject: function(init, accum) { var r = init; this.each(function (e) { r = accum(r,e); }); return r; },
  ...
}

function Range(from, to) {
  return object(
    compose(
      { each: function(fun) { for (var i = from; i < to; i++) { return fun(i) } },
      EnumerableTrait));
}

var r = Range(0,5);
r.inject(0,function(a,b){return a+b;}); // 10
}}}

The library does not explicitly distinguish traits from objects: any object can serve as a trait. Originally, traits were defines as stateless collections of methods. `traits.js` allows stateful traits and considers all own properties of a trait, regardless of whether they contain functions and regardless of whether they are data or accessor properties.

If a trait depends on mutable state, one should always "instantiate" such traits via 'maker' functions, to prevent a stateful trait from being composed multiple times with different objects (this is possible, but state would then be shared between the two composers, which may result in very bad interactions).

In `traits.js`, traits _provide_ a set of properties and may _require_ a set of properties, to be provided by other objects.

Traits can be composed into 'composite' traits. The composite consists of all of the own properties of the composed traits. The lexical scope of composed methods remains unmodified. However, when a trait is composed into a composite, the binding of `this` within the trait's methods will refer to the composite object. Hence, if a trait `T` defines a method `m` that requires (depends on) the method `r`, `m` should call this method using `this.r(...)`.

When two or more traits that define a property with the same name are composed, the composite property will be marked as a "conflict". Accessing a "conflict" property will raise an exception at runtime. 

At composition time, the composer can avoid name clashes by means of two operations:
  * either by *aliasing*, i.e. by renaming one of the conflicting properties in the composite
  * or by *exclusion*, i.e. by excluding one the conflicting properties from the composite

Traits form a composition mechanism that is entirely orthogonal to prototype-delegation (i.e. inheritance between objects). The 'parent' object of a trait is of no consequence: it is ignored during composition (composition of traits looks only at 'own' properties). Traits are assumed to be composed only via trait composition, not by means of delegation.

However, once all traits are composed into a composite that should be used as a 'finalized' or 'completed' object, that 'completed' object can itself take part in prototype-delegation like any other regular object. It may delegate to a parent object, and it may itself be delegated to by other objects.

TODO:
  * traits: summary, background, references
  * explain library API, four composition operators
  * explain `required` convention
  * diamond inheritance of methods
  * branding / testing 'type' of composed objects
  * performance and partial evaluation
  * show an example
  * compare with original traits (cf. Grafts proposal, compile-time vs run-time entities, state, computed exclude vs class precedence over traits)

== References ==

  * [1] "Traits: Composable units of Behavior" (Scharli et. al, ECOOP 2003) ([http://scg.unibe.ch/archive/papers/Scha03aTraits.pdf paper])
  * [2] "Adding State and Visibility Control to Traits using Lexical Nesting" (Van Cutsem et. al, ECOOP 2009) ([http://prog.vub.ac.be/Publications/2009/vub-prog-tr-09-04.pdf paper])
  * [3] [http://www.stefan-marr.de/pages/request-for-comments-horizontal-reuse-for-php Horizontal Reuse for PHP]: 'traits' vs 'grafts'