#summary A traits library for ES5

= Introduction =

The file [http://code.google.com/p/es-lab/source/browse/trunk/src/traits/traits.js traits.js] provides an [http://www.ecma-international.org/publications/standards/Ecma-262.htm ES5] implementation of Traits as defined in [[#References 1]] but closer to the object-based, lexically nestable traits defined in [[#References 2]]. The library has been successfully tested on Rhino (v1.7 release 3).

= Background: Traits =

Traits were originally defines as 'composable units of behavior' [[#References 1]]: reusable groups of methods that could be composed together to form a class. Their purpose is to encourage _reuse_ of methods across class hierarchies. Single-inheritance languages often suffer from methods being duplicated across hierarchies because single inheritance can only describe reuse trees, not graphs, often forcing programmers to violate the DRY principle.

Traits may _provide_ and _require_ a number of methods. Required methods are like abstract methods in OO class hierarchies: their implementation should be provided by another trait or class. For example, "enumerability" of a collection object can be encoded as a trait providing all kinds of higher-order methods on collections based on a single method `each` that returns successive elements of the collection (cf. Ruby's [http://ruby-doc.org/core/classes/Enumerable.html Enumerable module]) (I used pseudo-code for clarity):

{{{
trait Enumerable {
  provide {
    map: function(fun) { var r = []; this.each(function (e) { r.push(fun(e)); }); return r; },
    inject: function(init, accum) { var r = init; this.each(function (e) { r = accum(r,e); }); return r; },
  }
  require {
    each: function(fun);
  }
}

class Range(from, to) uses Enumerable {
  function each(fun) { for (var i = from; i < to; i++) { return fun(i) } }
}

var r = new Range(0,5);
r.inject(0,function(a,b){return a+b;}); // 10
}}}

Traits are not meant to be instantiated or used directly. They are only used to factor out and reusable sets of methods. Traits can be recursively composed into larger, but possibly still incomplete, traits. Classes can be composed with traits. Classes, unlike traits, must be complete (or remain abstract). Traits cannot be composed by means of inheritance, but a class composed of one or more traits can also take part in inheritance. Methods provided by traits then override methods inherited from its superclass. Traits and single inheritance are orthogonal and can coexist gracefully.

The big difference between traits and alternative composition techniques such as multiple inheritance and mixins is that upon trait composition, name conflicts (a.k.a. name clashes) should be explicitly resolved by the composer. This is in contrast to mixins and multiple inheritance, which define all kinds of linearization orderings that impose an implicit precedence on the composed entities, with one entity overriding the methods of another entity. While such systems often work for well in small reuse scenario's, they are not robust: small changes in the ordering of mixins/classes somewhere high up in the inheritance/mixin chain may impact the way name clashes are resolved further down the inheritance/mixin chain. In addition, the linearization imposed by mixins/multiple inheritance precludes a composer to favor a method m1 from one mixin/class A and a method m2 from another mixin/class B: either all of A's methods take precedence over B, or all of B's methods take precedence over A.

Traits allow composers to resolve name clashes by means of 2 fundamental "composition operators":
  * *aliasing*: the composer may choose to import a method under a different (non-conflicting) name.
  * *exclusion*: the composer may choose to explicitly exclude a name from the composition.

Name clashes that are never explicitly resolved will eventually lead to a composition error when traits are composed with a class. Depending on the language, this composition error may be a compiler error, a runtime error when the class is composed, or a runtime error when a conflicting name is invoked on a class instance.

Trait composition is declarative in the sense that the ordering of the composed traits does not matter. In other words, unlike mixins/multiple inheritance, trait composition is commutative and associative. This tremendously reduces the cognitive burden of reasoning about deeply nested levels of trait composition. In languages that support traits as a "compile-time" entity (similar to classes), trait composition can be entirely performed at compile-time, effectively "flattening" the composition and eliminating any composition overhead at runtime.

Since their publication in 2003, traits have received widespread adoption in the PL community, although the details of the many traits implementations differ significantly from the original implementation defined for Smalltalk. Traits have been adopted in Perl 6, Fortress, Dr. Scheme OO, Slate, ... Scala supports 'traits', although these should have been called 'mixins' (no explicit conflict resolution). Traits are considered for inclusion in many more languages, including PHP [[#References 3]].

= Traits for Javascript =

The above `Enumerable` example can be encoded using `traits.js` as follows:

{{{
var EnumerableTrait = {
  each: required, // should be provided by the composite
  map: function(fun) { var r = []; this.each(function (e) { r.push(fun(e)); }); return r; },
  inject: function(init, accum) { var r = init; this.each(function (e) { r = accum(r,e); }); return r; },
  ...
}

function Range(from, to) {
  return object(
    compose(
      { each: function(fun) { for (var i = from; i < to; i++) { return fun(i) } },
      EnumerableTrait));
}

var r = Range(0,5);
r.inject(0,function(a,b){return a+b;}); // 10
}}}

==== Traits vs Objects ====

`traits.js` does not explicitly distinguish traits from objects: any object can serve as a trait. Originally, traits were defines as stateless collections of methods. `traits.js` allows stateful traits and considers all own properties of a trait, regardless of whether they contain functions and regardless of whether they are data or accessor properties.

If a trait depends on mutable state, one should always "instantiate" such traits via 'maker' functions, to prevent a stateful trait from being composed multiple times with different objects (this is possible, but state would then be shared between the two composers, which may result in very bad interactions).

Traits can be composed into 'composite' traits. The composite consists of all of the own properties of the composed traits. The lexical scope of composed methods remains unmodified. However, when a trait is composed into a composite, the binding of `this` within the trait's methods will refer to the composite object. Hence, if a trait `T` defines a method `m` that requires (depends on) the method `r`, `m` should call this method using `this.r(...)`.

As mentioned in the background, trait composition is entirely orthogonal to inheritance. `traits.js` does not expect traits to take part in object-inheritance (i.e. prototype delegation). The 'prototype' of a trait is of no consequence: it is ignored during composition (composition of traits deals only with 'own' properties). Traits are assumed to be composed only via trait composition, not by means of delegation. However, once all traits are composed into a composite that should be used as a 'finalized' or 'completed' object, that 'completed' object _can_ take part in prototype-delegation like any regular Javascript object. It may delegate to a parent object, and it may itself be delegated to by other objects.

==== Composing traits ====

`traits.js` exports four "composition functions":
  * `compose(trait1, trait2, ..., traitN) -> compositeTrait`
  * `alias({ oldname: 'newname', ... }, trait) -> aliasedTrait`
  * `exclude([ 'name', ... ], trait) -> excludedTrait`
  * `object(trait, { extend: proto }) -> anObject`

The function `compose` composes zero or more traits into a single composite trait. The composite trait contains all of the own properties of all of the argument traits (including non-enumerable properties). For properties that appear in multiple argument traits, a special "conflicting" property is defined in the composite trait (see [#Conflicts below]). `compose` is a commutative and associative operation: the ordering of its arguments does not matter, and `compose(t1,t2,t3)` is equivalent to, for example, `compose(t1,compose(t2,t3))` or `compose(compose(t2,t1),t3)`.

The `alias` and `exclude` "operators" are defined as functions that transform a trait into a modified trait. `alias` takes as its first argument an object that serves as a map from old property names to new property names (the aliases). It returns a trait whose appropriate properties are renamed. `exclude` takes a list of property names and returns a trait without the properties named in the exclusion list.

Finally, the function `object` transforms a trait into an object. While `traits.js` does not distinguish traits from objects as such, the `object` function is the equivalent of "creating a class composed of one or more traits". The `object` function creates and returns a new object (let's name it `self`) that has all of the own properties of the argument trait, but additionally:
  * freezes `self`,
  * freezes all of `self`'s methods (including their `.prototype`),
  * turns all of`self`'s methods into _bound_ methods whose `this` is guaranteed to refer to `self`,
  * allows `self` to inherit from (delegate to) a `proto` object,
  * does not add `required` properties to `self` (see [#Required_properties below]), and optionally throws an exception if it encounters such a property,
  * optionally throws an exception if `trait` still contains "conflicting" properties (see [#Conflicts below]).

==== Required properties ====

In `traits.js`, required properties are defined as data properties bound to a distinguished singleton `required` object exported by the library. `traits.js` recognizes such data properties as required properties and they are treated specially by `object` (cf. previous section) and by `compose` (cf. the following section). Traits are not required to state their required properties explicitly.

The `object` function can enforce that the composite object is "complete" by throwing an exception if it encounters a lingering `required` property in its argument trait, by passing it the following option:

{{{
var o = object(trait, { failOnIncomplete: true });
}}}

By default, `object` silently filters out `required` properties of `trait`. The rationale is that missing `required` properties can always still be provided by a prototype object, or even a child object if `o`'s purpose is to serve as an "abstract prototype".

==== Conflicts ====

When `compose` encounters a property name that is defined by two or more argument traits, it marks the resulting property in the composite trait as a "conflicting property". Conflicting properties are accessor properties whose `get` and `set` methods raise an appropriate runtime exception upon use.

Two properties `p1` and `p2` with the same name do *not* lead to a conflict if:
  * `p1` or `p2` is a [Required_properties required] property. If either `p1` or `p2` is a non-required property, the `required` property is overridden by the non-required property.
  * `p1` and `p2` denote the "same" property. Two properties are considered to be the same if they refer to the same values. This implies that it is OK for properties to be "inherited" via multiple composition paths (cf. diamond inheritance: `T1 = compose(T2,T3)` where `T2 = compose(T4,...)` and `T3 = compose(T4, ...)`.

By default, `traits.js` allows conflicting properties to linger in even in finalized objects produced by `object`. However, this behavior can be changed by passing the following option to `object`:

{{{
var o = object(trait, { failOnConflicts: true });
}}}

Here, `o` is guaranteed not to contain conflicting properties. If `trait` does contain conflicts, the call to `object` will raise an exception.

== An Example ==

TODO: explain the morph/animationtrait example.

== Performance ==

TODO: Performance overhead. Partial evaluation scheme that would enable a smart implementation to perform trait composition at 'load-time'.

== TODO ==
  * diamond inheritance of methods
  * branding / testing 'type' of composed objects
  * compare with original traits (cf. Grafts proposal, compile-time vs run-time entities, state, computed exclude vs class precedence over traits)

== References ==

  * [[1]] "Traits: Composable units of Behavior" (Scharli et. al, ECOOP 2003) ([http://scg.unibe.ch/archive/papers/Scha03aTraits.pdf paper])
  * [[2]] "Adding State and Visibility Control to Traits using Lexical Nesting" (Van Cutsem et. al, ECOOP 2009) ([http://prog.vub.ac.be/Publications/2009/vub-prog-tr-09-04.pdf paper])
  * [[3]] [http://www.stefan-marr.de/pages/request-for-comments-horizontal-reuse-for-php Horizontal Reuse for PHP]: 'traits' vs 'grafts'