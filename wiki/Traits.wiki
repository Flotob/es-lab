#summary A traits library for ES5

= Introduction =

[http://code.google.com/p/es-lab/source/browse/trunk/src/traits/traits.js traits.js] is a Javascript library for Trait composition, as originally proposed in [[#References 1]] but closer to the object-based, lexically nestable traits defined in [[#References 2]]. The library has been designed for [http://www.ecma-international.org/publications/standards/Ecma-262.htm Ecmascript 5], but should be backwards-compatible with existing Ecmascript 3 implementations. In fact, the ES5-specific extensions have already been tested on Rhino (v1.7 release 3) (which supports most of ES5 except strict-mode).

Note: this library is under active development and may still undergo some redesign. Don't rely on it just yet, but do feel free to experiment with it!

= Background: Traits =

Traits were originally defined as 'composable units of behavior' [[#References 1]]: reusable groups of methods that could be composed together to form a class. Their purpose is to enable _reuse_ of methods across class hierarchies. Single-inheritance class hierarchies often suffer from methods being duplicated across the hierarchy, because a class cannot inherit methods from two separate sources. Hence, single inheritance often forces programmers to violate the DRY principle.

Traits may _provide_ and _require_ a number of methods. Required methods are like abstract methods in OO class hierarchies: their implementation should be provided by another trait or class. For example, "enumerability" of a collection object can be encoded as a trait providing all kinds of higher-order methods on collections based on a single method `each` that returns successive elements of the collection (cf. Ruby's [http://ruby-doc.org/core/classes/Enumerable.html Enumerable module]) (I used pseudo-code for clarity):

{{{
trait Enumerable {
  provide {
    map: function(fun) { var r = []; this.each(function (e) { r.push(fun(e)); }); return r; },
    inject: function(init, accum) { var r = init; this.each(function (e) { r = accum(r,e); }); return r; },
    ...
  }
  require {
    each: function(fun);
  }
}

class Range(from, to) uses Enumerable {
  function each(fun) { for (var i = from; i < to; i++) { return fun(i); } }
}

var r = new Range(0,5);
r.inject(0,function(a,b){return a+b;}); // 10
}}}

Traits are not meant to be instantiated or used directly. They are only used to factor out and compose reusable sets of methods. Traits can be recursively composed into larger, but possibly still incomplete, traits. Classes can be composed from zero or more traits. Classes, unlike traits, must be complete (or remain abstract). Traits cannot be composed by means of inheritance, but a class composed of one or more traits can take part in single inheritance. Methods provided by traits then override methods inherited from its superclass.

The big difference between traits and alternative composition techniques such as multiple inheritance and mixins is that upon trait composition, name conflicts (a.k.a. name clashes) should be explicitly resolved by the composer. This is in contrast to mixins and multiple inheritance, which define all kinds of linearization schemes that impose an implicit precedence on the composed entities, with one entity overriding all of the methods of another entity. While such systems often work for well in small reuse scenarios, they are not robust: small changes in the ordering of mixins/classes somewhere high up in the inheritance/mixin chain may impact the way name clashes are resolved further down the inheritance/mixin chain. In addition, the linearization imposed by mixins/multiple inheritance precludes a composer to give precedence to both a method m1 from one mixin/class A and a method m2 from another mixin/class B: either all of A's methods take precedence over B, or all of B's methods take precedence over A.

Traits allow composers to resolve name clashes by means of three "composition operators":
  * *aliasing*: the composer may import a method under a different (non-conflicting) name.
  * *exclusion*: the composer may explicitly exclude a method from the composition.
  * *overriding*: the composer chooses to resolve name clashes by having all of one trait's methods take precedence over the other.

Name clashes that are never explicitly resolved will eventually lead to a composition error when traits are composed with a class. Depending on the language, this composition error may be a compile-time error, a runtime error when the class is composed, or a runtime error when a conflicting name is invoked on a class instance.

Trait composition is declarative in the sense that the ordering of composed traits does not matter. In other words, unlike mixins/multiple inheritance, trait composition is commutative and associative. This tremendously reduces the cognitive burden of reasoning about deeply nested levels of trait composition. In languages that support traits as a compile-time entity (similar to classes), trait composition can be entirely performed at compile-time, effectively "flattening" the composition and eliminating any composition overhead at runtime.

Since their publication in 2003, traits have received widespread adoption in the PL community, although the details of the many traits implementations differ significantly from the original implementation defined for Smalltalk. Traits have been adopted in Perl 6, Fortress, Dr. Scheme OO, Slate, ... Scala supports 'traits', although these should have been called 'mixins' (no explicit conflict resolution). Traits are considered for inclusion in many more languages, including PHP [[#References 3]].

= Traits for Javascript =

The above `Enumerable` example can be encoded using `traits.js` as follows:

{{{
var EnumerableTrait = trait({
  each: required, // should be provided by the composite
  map: function(fun) { var r = []; this.each(function (e) { r.push(fun(e)); }); return r; },
  inject: function(init, accum) { var r = init; this.each(function (e) { r = accum(r,e); }); return r; },
  ...
});

function Range(from, to) {
  return object(
    compose(
      trait({ each: function(fun) { for (var i = from; i < to; i++) { return fun(i) } }),
      EnumerableTrait));
}

var r = Range(0,5);
r.inject(0,function(a,b){return a+b;}); // 10
}}}

==== Traits vs Objects ====

`traits.js` explicitly distinguishes traits from objects since traits are not meant to be used as objects. Traits are only meant to be composed _into_ objects. Traits are really just records of properties. In fact, traits are represented by `traits.js` as property maps: objects whose keys represent property names and whose values are Ecmascript 5 "property descriptors".

Basic traits can be created from simple object descriptions (usually Javascript object literals) and further composed into 'composite' traits using a small set of composition functions (explained below). In order to use a (composite) trait, it must first be "instantiated" into an object. When a trait is instantiated into such a composite object, the binding of the `this` pseudovariable within the trait's methods will refer to that composite object. If a trait `T` defines a method `m` that requires (depends on) the method `r`, `m` should call this method using `this.r(...)`, and if that method was provided by some other trait, it will be found in the composite object. The lexical scope of composed trait methods remains unaffected by trait composition.

Originally, traits were defined as stateless collections of methods only. `traits.js` allows stateful traits and allows traits to describe any Javascript property, regardless of whether it contains a function and regardless of whether it is a data or accessor property. If a trait property depends on mutable state, one should always "instantiate" such traits via 'maker' functions, to prevent a stateful trait from being composed multiple times with different objects (this is possible, but state would then be shared between the two composers, which may result in very bad interactions).

As mentioned in the background, trait composition is entirely orthogonal to inheritance. `traits.js` does not expect traits to take part in object-inheritance (i.e. prototype delegation). Traits do not have a "prototype", and the objects they instantiate always inherit from `Object.prototype`. Traits should be composed only via trait composition. As explained below, the `override` composition function can still be used to emulate the behavior of inheritance where this is useful.

==== Composing traits ====

`traits.js` exports six "composition functions":
  * `trait({ ... }) -> newTrait`
  * `compose(trait1, trait2, ..., traitN) -> compositeTrait`
  * `alias({ oldname: 'newname', ... }, trait) -> aliasedTrait`
  * `exclude([ 'name', ... ], trait) -> excludedTrait`
  * `override(dominantT, recessiveT) -> overriddenTrait`
  * `object(trait, options) -> anObject`

All of the above functions save `object` are pure: they never modify their argument values and they do not depend on mutable state across invocations. `object` additionally freezes the `.prototype` of the trait's methods (see below), but is pure if those prototypes are already frozen.

The function `trait` allows one to define "simple" (non-composite) traits. It essentially turns an object record into a trait. Since only the provided object's own properties are considered, it is conventional to invoke `trait` only with object _literals_. The objects passed to `trait` should really only serve to describe a simple trait's properties, they typically shouldn't serve any other purpose. The `trait` function accepts an object only because we want to leverage the expressiveness of Javascript's excellent object literal syntax.

The function `compose` is the workhorse of `traits.js`. It composes zero or more traits into a single composite trait. The composite trait contains all of the own properties of all of the argument traits (including non-enumerable properties). For properties that appear in multiple argument traits, a distinct "conflicting" property is defined in the composite trait (see [#Conflicts below]). `compose` is a commutative and associative operation: the ordering of its arguments does not matter, and `compose(t1,t2,t3)` is equivalent to, for example, `compose(t1,compose(t2,t3))` or `compose(compose(t2,t1),t3)`.

The `alias` and `exclude` "operators" are defined as functions that transform a trait into a modified trait. `alias` takes as its first argument an object that serves as a map from old property names to new property names (the aliases). It returns a trait whose appropriate properties are renamed. `exclude` takes a list of property names and returns a trait without the properties named in the exclusion list.

The `override` function takes two traits and returns a composite trait containing all properties of `dominantT` and all properties of `recessiveT` not in `dominantT`. `override` is obviously not commutative, but it is associative, i.e. `override(t1,override(t2,t3))` is equivalent to `override(override(t1,t2),t3)`. Composition via `override` most closely resembles the kind of composition provided by single inheritance.

Finally, the function `object` "instantiates" a trait into an object. It is the Javascript equivalent of "creating a class composed of one or more traits". The `object` function creates and returns a new object (let's name it `self`) that has all of the own properties of the argument trait, but additionally:
  * freezes `self`,
  * freezes all of `self`'s methods (including their `.prototype`),
  * turns all of`self`'s methods into _bound_ methods whose `this` is guaranteed to refer to `self`,
  * does not add `required` properties to `self` (see [#Required_properties below]), and optionally throws an exception if it encounters such a property,
  * optionally throws an exception if `trait` still contains "conflicting" properties (see [#Conflicts below]).

==== Required properties ====

In `traits.js`, required properties are defined as data properties bound to a distinguished singleton `required` object exported by the library. `traits.js` recognizes such data properties as required properties and they are treated specially by `object` (cf. previous section) and by `compose` (cf. the following section). Traits are not required to state their required properties explicitly.

The `object` function can enforce that the composite object is "complete" by throwing an exception if it encounters a lingering `required` property in its argument trait, by passing it the following option:

{{{
var o = object(trait, { failOnIncomplete: true });
}}}

By default, `object` silently filters out any `required` properties left in `trait`.
TODO: consider another default.

The `alias` and `exclude` operators are neutral with respect to required properties: aliasing or excluding a required property has no effect.

==== Conflicts ====

When `compose` encounters a property name that is defined by two or more argument traits, it marks the resulting property in the composite trait as a "conflicting property". Conflicting properties are accessor properties whose `get` and `set` methods raise an appropriate runtime exception when invoked.

Two properties `p1` and `p2` with the same name do *not* lead to a conflict if:
  * `p1` or `p2` is a [#Required_properties required] property. If either `p1` or `p2` is a non-required property, the `required` property is overridden by the non-required property.
  * `p1` and `p2` denote the "same" property. Two properties are considered to be the same if they refer to the same values. This implies that it is OK for properties to be "inherited" via multiple composition paths (cf. diamond inheritance: `T1 = compose(T2,T3)` where `T2 = compose(T4,...)` and `T3 = compose(T4, ...)`.

By default, `traits.js` allows conflicting properties to linger even in finalized objects produced by `object`. However, this behavior can be changed by passing the following option to `object`:

{{{
var o = object(trait, { failOnConflicts: true });
}}}

Here, `o` is guaranteed not to contain conflicting properties. If `trait` does contain conflicts, the call to `object` will raise an exception.

== An Example ==

TODO: explain the [http://code.google.com/p/es-lab/source/browse/trunk/src/traits/trait-example.js animationtrait example].

== What about inheritance? ==

TODO: stress that traits.js can completely replace all use of inheritance.

== Performance ==

Because trait composition is essentially flattened out when a trait is instantiated into an object, the resulting object is essentially fully self-contained. It does not depend on a prototype object and as a result, method lookup is confined only to the object itself (except for methods inherited from `Object.prototype`). There is no inheritance chain to traverse.

The downside of trait composition by flattening is that the resulting objects are more "fat" (the number of methods per object is larger). To reduce the memory footprint, an efficient implementation should share the property structure resulting from a trait instantiation between all objects instantiated from the same trait. That is, it should be able to construct a single vtable to be shared by all objects returned from a single `object` callsite.

While designing this library, great care has been taken to allow a Javascript engine to partially evaluate trait composition at "compile-time". In order for the partial evaluation scheme to work, programmers should use the library with some restrictions:
  * The argument to `trait` should be an object literal.
  * The first argument to `alias` should be an object literal whose properties are string literals.
  * The first argument to `exclude` should be an array literal of string literals.
  * Arguments to all six composition functions should be either variables that are lexically bound to the result of a call to `trait` or one of the other functions, or they should be function calls whose function identifier is lexically bound to a function that is known to return a trait.

At first sight, these restrictions may look severe. However, recall that traits should be thought of more as classes than as objects: they are meant to describe the structure of objects, and the above constraints are trivially satisfied if you use traits as the declarative entities they are meant to be. Now, the cool thing about `traits.js` is that it does not preclude programmers from violating these restrictions, enabling programmers to generate traits at runtime. These traits won't be able to make use of optimized trait composition and instantiation, but that's a fair tradeoff to be made. It's like generating a Java class at runtime.

Partial evaluation would enable a smart implementation to transform the composition functions as follows:

{{{
trait({ a: 1, ... }) => literal-property-map
compose(trait({ a: 1 }), trait({ b: 2})) => trait({ a:1, b:2 })
alias({ a: 'x' , ... } , trait({ a: 1, b: 2, ... })) => trait({ x: 1, b:2, ... })
exclude([ 'a' ], trait({ a: 1, b: 2, ...})) => trait({ b: 2, ... })
override(trait({a: 1, b: 2}), trait({ a: 3, b: 4, c: 5 })) => trait({ a: 1, b:2, c: 5})
object(literal-property-map) => replace by a native implementation (objects generated from this call-site can share a custom vtable)
}}}

A `literal-property-map` is a property map defined as an object literal, with all of the required structural information available "at compile time". The key idea of the partial evaluation is that calls to `object` with a literal property map can be transformed into a fast native implementation of `object` whose instances can share structure.

== Traits and type tests ==

`traits.js` does not provide an operator to test whether an object was instantiated from a particular trait. In principle, traits are not meant to be used as a type/classification mechanism. This is better left to separate, orthogonal concepts such as interfaces.

If Javascript would at some point have the notion of interfaces or "brands" to classify objects, the API of the `object` function could be extended to allow for objects to be "branded" as follows:

{{{
var o = object(trait, { implements: [ brand1, brand2, ... ] });
}}}

== traits.js vs original traits ==

TODO: comparison table with original traits (cf. Grafts proposal, compile-time vs run-time entities, state, override vs class precedence over traits)

== References ==

  * [[1]] "Traits: Composable units of Behavior" (Scharli et. al, ECOOP 2003) ([http://scg.unibe.ch/archive/papers/Scha03aTraits.pdf paper])
  * [[2]] "Adding State and Visibility Control to Traits using Lexical Nesting" (Van Cutsem et. al, ECOOP 2009) ([http://prog.vub.ac.be/Publications/2009/vub-prog-tr-09-04.pdf paper])
  * [[3]] [http://www.stefan-marr.de/pages/request-for-comments-horizontal-reuse-for-php Horizontal Reuse for PHP]: 'traits' vs 'grafts'