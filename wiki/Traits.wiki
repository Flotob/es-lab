#summary A traits library for ES5

= Introduction =

The file [http://code.google.com/p/es-lab/source/browse/trunk/src/traits/traits.js traits.js] provides an [http://www.ecma-international.org/publications/standards/Ecma-262.htm ES5] implementation of Traits as defined in [[#References 1]] but closer to the object-based, lexically nestable traits defined in [[#References 2]]. The library has been successfully tested on Rhino (v1.7 release 3).

= Background: Traits =

Traits were originally defines as 'composable units of behavior' [[#References 1]]: reusable groups of methods that could be composed together to form a class. Their purpose is to encourage _reuse_ of methods across class hierarchies. Single-inheritance languages often suffer from methods being duplicated across hierarchies because single inheritance can only describe reuse trees, not graphs, often forcing programmers to violate the DRY principle.

Traits may _provide_ and _require_ a number of methods. Required methods are like abstract methods in OO class hierarchies: their implementation should be provided by another trait or class. For example, "enumerability" of a collection object can be encoded as a trait providing all kinds of higher-order methods on collections based on a single method `each` that returns successive elements of the collection (cf. Ruby's [http://ruby-doc.org/core/classes/Enumerable.html Enumerable module]) (I used pseudo-code for clarity):

{{{
trait Enumerable {
  provide {
    map: function(fun) { var r = []; this.each(function (e) { r.push(fun(e)); }); return r; },
    inject: function(init, accum) { var r = init; this.each(function (e) { r = accum(r,e); }); return r; },
  }
  require {
    each: function(fun);
  }
}

class Range(from, to) uses Enumerable {
  function each(fun) { for (var i = from; i < to; i++) { return fun(i) } }
}

var r = new Range(0,5);
r.inject(0,function(a,b){return a+b;}); // 10
}}}

Traits are not meant to be instantiated or used directly. They are only used to factor out and reusable sets of methods. Traits can be recursively composed into larger, but possibly still incomplete, traits. Classes can be composed with traits. Classes, unlike traits, must be complete (or remain abstract). Traits cannot be composed by means of inheritance, but a class composed of one or more traits can also take part in inheritance. Methods provided by traits then override methods inherited from its superclass. Traits and single inheritance are orthogonal and can coexist gracefully.

The big difference between traits and alternative composition techniques such as multiple inheritance and mixins is that upon trait composition, name conflicts (a.k.a. name clashes) should be explicitly resolved by the composer. This is in contrast to mixins and multiple inheritance, which define all kinds of linearization orderings that impose an implicit precedence on the composed entities, with one entity overriding the methods of another entity. While such systems often work for well in small reuse scenario's, they are not robust: small changes in the ordering of mixins/classes somewhere high up in the inheritance/mixin chain may impact the way name clashes are resolved further down the inheritance/mixin chain. In addition, the linearization imposed by mixins/multiple inheritance precludes a composer to favor a method m1 from one mixin/class A and a method m2 from another mixin/class B: either all of A's methods take precedence over B, or all of B's methods take precedence over A.

Traits allow composers to resolve name clashes by means of 2 fundamental "composition operators":
  * *aliasing*: the composer may choose to import a method under a different (non-conflicting) name.
  * *exclusion*: the composer may choose to explicitly exclude a name from the composition.

Name clashes that are never explicitly resolved will eventually lead to a composition error when traits are composed with a class. Depending on the language, this composition error may be a compiler error, a runtime error when the class is composed, or a runtime error when a conflicting name is invoked on a class instance.

Trait composition is declarative in the sense that the ordering of the composed traits does not matter. In other words, unlike mixins/multiple inheritance, trait composition is commutative and associative. This tremendously reduces the cognitive burden of reasoning about deeply nested levels of trait composition. In languages that support traits as a "compile-time" entity (similar to classes), trait composition can be entirely performed at compile-time, effectively "flattening" the composition and eliminating any composition overhead at runtime.

Since their publication in 2003, traits have received widespread adoption in the PL community, although the details of the many traits implementations differ significantly from the original implementation defined for Smalltalk. Traits have been adopted in Perl 6, Fortress, Dr. Scheme OO, Slate, ... Scala supports 'traits', although these should have been called 'mixins' (no explicit conflict resolution). Traits are considered for inclusion in many more languages, including PHP [[#References 3]].

= Traits for Javascript =

The above `Enumerable` example can be encoded using `traits.js` as follows:

{{{
var EnumerableTrait = {
  each: required, // should be provided by the composite
  map: function(fun) { var r = []; this.each(function (e) { r.push(fun(e)); }); return r; },
  inject: function(init, accum) { var r = init; this.each(function (e) { r = accum(r,e); }); return r; },
  ...
}

function Range(from, to) {
  return object(
    compose(
      { each: function(fun) { for (var i = from; i < to; i++) { return fun(i) } },
      EnumerableTrait));
}

var r = Range(0,5);
r.inject(0,function(a,b){return a+b;}); // 10
}}}

`traits.js` does not explicitly distinguish traits from objects: any object can serve as a trait. Originally, traits were defines as stateless collections of methods. `traits.js` allows stateful traits and considers all own properties of a trait, regardless of whether they contain functions and regardless of whether they are data or accessor properties.

If a trait depends on mutable state, one should always "instantiate" such traits via 'maker' functions, to prevent a stateful trait from being composed multiple times with different objects (this is possible, but state would then be shared between the two composers, which may result in very bad interactions).

In `traits.js`, required properties can be expressed as data properties bound to a distinguished singleton `required` object. The library recognizes such data properties as required properties. Traits are not required to state their required properties explicitly.

Traits can be composed into 'composite' traits. The composite consists of all of the own properties of the composed traits. The lexical scope of composed methods remains unmodified. However, when a trait is composed into a composite, the binding of `this` within the trait's methods will refer to the composite object. Hence, if a trait `T` defines a method `m` that requires (depends on) the method `r`, `m` should call this method using `this.r(...)`.

When two or more traits that define a property with the same name are composed, the composite property will be marked as a "conflict". Accessing a "conflict" property will raise an exception at runtime. 

`traits.js` exports four "composition functions":
  * `compose(trait1, trait2, ..., traitN) -> compositeTrait`
  * `alias({ oldname: 'newname', ... }, trait) -> aliasedTrait`
  * `exclude([ 'name', ... ], trait) -> excludedTrait`
  * `object(trait, {extend: proto})` -> anObject`

TODO: explain in more detail

Traits form a composition mechanism that is entirely orthogonal to prototype-delegation (i.e. inheritance between objects). The 'parent' object of a trait is of no consequence: it is ignored during composition (composition of traits looks only at 'own' properties). Traits are assumed to be composed only via trait composition, not by means of delegation.

However, once all traits are composed into a composite that should be used as a 'finalized' or 'completed' object, that 'completed' object can itself take part in prototype-delegation like any other regular object. It may delegate to a parent object, and it may itself be delegated to by other objects.

== An Example ==

TODO: explain the morph/animationtrait example.

== Performance ==

TODO: Performance overhead. Partial evaluation scheme that would enable a smart implementation to perform trait composition at 'load-time'.

== TODO ==
  * diamond inheritance of methods
  * branding / testing 'type' of composed objects
  * compare with original traits (cf. Grafts proposal, compile-time vs run-time entities, state, computed exclude vs class precedence over traits)

== References ==

  * [1] "Traits: Composable units of Behavior" (Scharli et. al, ECOOP 2003) ([http://scg.unibe.ch/archive/papers/Scha03aTraits.pdf paper])
  * [2] "Adding State and Visibility Control to Traits using Lexical Nesting" (Van Cutsem et. al, ECOOP 2009) ([http://prog.vub.ac.be/Publications/2009/vub-prog-tr-09-04.pdf paper])
  * [3] [http://www.stefan-marr.de/pages/request-for-comments-horizontal-reuse-for-php Horizontal Reuse for PHP]: 'traits' vs 'grafts'